Please help me build a complete restaurant ranking system for DC restaurants using Next.js, Prisma, and TypeScript.

Requirements:

1. Core Features:
- Restaurant A/B comparison UI
- Simple choice tracking
- Recommendations based on choices
- Restaurant filtering by cuisine/area
- Mobile-first design

2. Technical Stack:
- T3 Stack base
- Supabase database
- Vercel deployment
- Tailwind styling

3. Initial Data:
- 100 DC restaurants (focus on popular areas)
- Cuisine types and tags
- Basic metadata

4. Core Algorithms:
- CrowdBT for rankings
- Simple collaborative filtering
- Context-aware recommendations

Please implement the following code:
*/

// 1. DATA MODELS
// prisma/schema.prisma
model Restaurant {
  id          String   @id @default(cuid())
  name        String
  area        String   // DC neighborhood
  cuisineTypes String[]
  tags        String[]
  rating      Rating?
  winComparisons  Comparison[] @relation("WinnerComparisons")
  loseComparisons Comparison[] @relation("LoserComparisons")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model Rating {
  id           String   @id @default(cuid())
  restaurantId String   @unique
  restaurant   Restaurant @relation(fields: [restaurantId], references: [id])
  mu          Float    @default(0)    // CrowdBT mean
  sigma       Float    @default(1)    // Uncertainty
  updatedAt   DateTime @updatedAt
}

model Comparison {
  id        String   @id @default(cuid())
  winnerId  String
  loserId   String
  userId    String
  winner    Restaurant @relation("WinnerComparisons", fields: [winnerId], references: [id])
  loser     Restaurant @relation("LoserComparisons", fields: [loserId], references: [id])
  context   Json     // timeOfDay, occasion, etc.
  createdAt DateTime @default(now())
}

// 2. CORE ALGORITHMS
// lib/crowdbt.ts
export class CrowdBT {
  private readonly beta: number;
  private readonly gamma: number;

  constructor(beta = 0.5, gamma = 0.5) {
    this.beta = beta;
    this.gamma = gamma;
  }

  updateRatings(winner: Rating, loser: Rating): void {
    const expectedWin = this.probability(winner.mu, loser.mu);
    const k = this.beta * (1 - expectedWin);

    winner.mu += k * winner.sigma;
    loser.mu -= k * loser.sigma;

    winner.sigma *= Math.max(1 - this.gamma * k * winner.sigma, 0.1);
    loser.sigma *= Math.max(1 - this.gamma * k * loser.sigma, 0.1);
  }

  private probability(mu1: number, mu2: number): number {
    return 1 / (1 + Math.exp(mu2 - mu1));
  }
}

// lib/recommender.ts
export class Recommender {
  async getUserPreferences(userId: string): Promise<Map<string, number>> {
    const choices = await prisma.comparison.findMany({
      where: { userId },
      include: {
        winner: true,
        loser: true
      },
      orderBy: { createdAt: 'desc' },
      take: 50
    });

    const preferences = new Map<string, number>();
    
    choices.forEach(choice => {
      choice.winner.cuisineTypes.forEach(cuisine => {
        preferences.set(cuisine, (preferences.get(cuisine) || 0) + 1);
      });
      choice.loser.cuisineTypes.forEach(cuisine => {
        preferences.set(cuisine, (preferences.get(cuisine) || 0) - 0.5);
      });
    });

    return preferences;
  }

  async getRecommendations(userId: string, context: any): Promise<Restaurant[]> {
    const preferences = await this.getUserPreferences(userId);
    const similarUsers = await this.findSimilarUsers(userId, preferences);
    
    return prisma.restaurant.findMany({
      where: {
        id: {
          notIn: await this.getUserSeenRestaurants(userId)
        },
        cuisineTypes: {
          hasSome: Array.from(preferences.keys())
        }
      },
      orderBy: {
        rating: {
          mu: 'desc'
        }
      },
      take: 10
    });
  }

  private async findSimilarUsers(userId: string, preferences: Map<string, number>) {
    // Find users with similar choice patterns
    const userChoices = await prisma.comparison.findMany({
      where: { userId },
      select: { winnerId: true }
    });

    return prisma.comparison.findMany({
      where: {
        userId: { not: userId },
        winnerId: { in: userChoices.map(c => c.winnerId) }
      },
      select: { userId: true },
      distinct: ['userId'],
      take: 10
    });
  }
}

// 3. UI COMPONENTS
// components/ComparisonView.tsx
export const ComparisonView: React.FC = () => {
  const [pair, setPair] = useState<[Restaurant, Restaurant]>();
  const { data: restaurants } = api.restaurant.getPair.useQuery();
  const submitChoice = api.restaurant.submitChoice.useMutation();

  const handleChoice = async (winnerId: string) => {
    if (!pair) return;
    const loserId = pair.find(r => r.id !== winnerId)?.id;
    if (!loserId) return;

    await submitChoice.mutateAsync({
      winnerId,
      loserId,
      context: {
        timeOfDay: getTimeOfDay(),
        occasion: 'casual' // could be dynamic
      }
    });

    // Get new pair
    setPair(undefined);
  };

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4 p-4">
      {pair?.map(restaurant => (
        <Card
          key={restaurant.id}
          className="p-4 hover:shadow-lg cursor-pointer"
          onClick={() => handleChoice(restaurant.id)}
        >
          <h3 className="text-lg font-bold">{restaurant.name}</h3>
          <div className="flex flex-wrap gap-2 mt-2">
            {restaurant.cuisineTypes.map(type => (
              <span
                key={type}
                className="px-2 py-1 bg-gray-100 rounded-full text-sm"
              >
                {type}
              </span>
            ))}
          </div>
          <div className="mt-2 text-gray-600">
            {restaurant.area}
          </div>
        </Card>
      ))}
    </div>
  );
};

// 4. API ROUTES
// server/api/routers/restaurant.ts
export const restaurantRouter = createTRPCRouter({
  getPair: publicProcedure
    .input(
      z.object({
        cuisineType: z.string().optional(),
        area: z.string().optional()
      })
    )
    .query(async ({ ctx, input }) => {
      const restaurants = await ctx.prisma.restaurant.findMany({
        where: {
          cuisineTypes: input.cuisineType ? {
            has: input.cuisineType
          } : undefined,
          area: input.area,
        },
        orderBy: {
          _count: {
            winComparisons: 'asc'
          }
        },
        take: 2,
      });

      return restaurants;
    }),

  submitChoice: publicProcedure
    .input(
      z.object({
        winnerId: z.string(),
        loserId: z.string(),
        context: z.any()
      })
    )
    .mutation(async ({ ctx, input }) => {
      const [winner, loser] = await Promise.all([
        ctx.prisma.rating.findUnique({
          where: { restaurantId: input.winnerId }
        }),
        ctx.prisma.rating.findUnique({
          where: { restaurantId: input.loserId }
        })
      ]);

      if (!winner || !loser) throw new Error("Ratings not found");

      const crowdBT = new CrowdBT();
      crowdBT.updateRatings(winner, loser);

      await ctx.prisma.$transaction([
        ctx.prisma.rating.update({
          where: { id: winner.id },
          data: { mu: winner.mu, sigma: winner.sigma }
        }),
        ctx.prisma.rating.update({
          where: { id: loser.id },
          data: { mu: loser.mu, sigma: loser.sigma }
        }),
        ctx.prisma.comparison.create({
          data: {
            winnerId: input.winnerId,
            loserId: input.loserId,
            userId: ctx.session?.user?.id ?? 'anonymous',
            context: input.context
          }
        })
      ]);
    }),

  getRecommendations: publicProcedure
    .input(
      z.object({
        context: z.any()
      })
    )
    .query(async ({ ctx, input }) => {
      const recommender = new Recommender();
      return recommender.getRecommendations(
        ctx.session?.user?.id ?? 'anonymous',
        input.context
      );
    })
});

// 5. INITIAL DATA
const INITIAL_RESTAURANTS = [
  {
    name: "Rose's Luxury",
    area: "Capitol Hill",
    cuisineTypes: ["American", "Contemporary"],
    tags: ["upscale", "creative", "popular"]
  },
  {
    name: "Bad Saint",
    area: "Columbia Heights",
    cuisineTypes: ["Filipino", "Asian"],
    tags: ["casual", "authentic", "small plates"]
  },
  // ... add more DC restaurants
];

// Instructions to run:
/*
1. Setup:
- Clone T3 stack
- Copy this code
- Setup Supabase
- Add environment variables

2. Development:
- npm install
- npm run dev
- Visit localhost:3000

3. Deployment:
- Push to GitHub
- Connect to Vercel
- Deploy

4. Initial Data:
- Run seed script
- Verify database
- Test basic functionality